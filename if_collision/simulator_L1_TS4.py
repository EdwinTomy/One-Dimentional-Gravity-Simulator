#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Oct 20 14:47:27 2020@author: edwintomy"""from scipy.constants import G as Gimport numpy as npimport matplotlib.pyplot as pltfrom math import expimport pandas as pdimport sklearn.neural_network as NWfrom sklearn.linear_model import LinearRegressionfrom sklearn.linear_model import LogisticRegressionfrom sklearn import metricsfrom sklearn.metrics import classification_report, confusion_matriximport seaborn as sns# Import `Sequential` from `keras.models`from keras.models import Sequential# Import `Dense` from `keras.layers`from keras.layers import Dense#%%upper_border = 5time_step = 0.0001soften = 10 #exponente^(-r/lamba)lam = 0.1total_train = 9000total_test = 1000mass_base = 10000000000border = 5class Particle():    def __init__(self, mass, vel, x_pos, collided = 100000):        self.mass = mass        self.vel = vel        self.x_pos = x_pos        self.collided = collided            def potential_U(self, other):        return -abs(G * self.mass * other.mass / (other.x_pos - self.x_pos))        def kinetic_E(self):        return self.mass * self.vel * self.vel / 2# Bounds the particles inside the borderdef bound(particle, upper_border = upper_border, lower_border = 0):    return     if particle.x_pos > upper_border:        particle.vel *= -1        particle.x_pos = 2*upper_border - particle.x_pos            if particle.x_pos < lower_border:        particle.vel *= -1        particle.x_pos = 2*lower_border - particle.x_pos        def lambda_F(r):    #print(1 - exp(-abs(r)/lam))    return exp(-abs(r)/lam)        # Acceleration from gravitational force       def acc(particle, other, soften = soften):        #force = G * particle.mass * other_particle.mass/((other.x_pos - particle.x_pos)**2 + soften)    r = other.x_pos - particle.x_pos    force = G * particle.mass * other.mass/((r**2) + lambda_F(r))    force *= np.sign(other.x_pos - particle.x_pos)    return force/particle.massdef ellastic_collision(a, b):    vel_a = (((a.mass - b.mass)/(a.mass + b.mass))*a.vel)+(((2*b.mass)/(a.mass + b.mass))*b.vel)    vel_b = (((2*a.mass)/(a.mass + b.mass))*a.vel)-(((a.mass - b.mass)/(a.mass + b.mass))*b.vel)    a.vel = vel_a    b.vel = vel_b    def inellastic_collision(a, b):    vel = (a.mass*a.vel + b.mass*b.vel)/(a.mass + b.mass)    a.vel = vel    b.vel = veldef iteration(a, b, phantom = True, ellastic = True, step = time_step):        # Kinematic equations    vel_a = a.vel + acc(a, b) * step    vel_b = b.vel + acc(b, a) * step    pos_a = a.x_pos + step * (vel_a + a.vel)/2    pos_b = b.x_pos + step * (vel_b + b.vel)/2            # Collision    if (a.x_pos > b.x_pos) != (pos_a > pos_b):        if not phantom:            a.collided = 0            b.collided = 0            if ellastic:                ellastic_collision(a, b)                return #collision             else:                inellastic_collision(a, b)                a.x_pos = pos_a                b.x_pos = pos_b                return #collision                              a.vel = vel_a    b.vel = vel_b    a.x_pos = pos_a    b.x_pos = pos_b            if abs(a.x_pos - b.x_pos) < a.collided:        a.collided = abs(pos_a - pos_b)        b.collided = abs(pos_a - pos_b)        return #collision    #%% Phantom# masses of 10 billion kga = Particle(10000000000, 0, 1.5)b = Particle(10000000000, 0, 1.6)time_phantom = 100000arr_phantom = np.zeros((time_phantom, 2, 4))# Index 0: Which time mark# Index 1: Which particle # Index 2: Which particle characteristic (x_pos, vel, potential_U, kinetic_E)for i in range(time_phantom):    arr_phantom[i][0][0] = a.x_pos    arr_phantom[i][0][1] = a.vel    arr_phantom[i][0][2] = a.potential_U(b)    arr_phantom[i][0][3] = a.kinetic_E()        arr_phantom[i][1][0] = b.x_pos    arr_phantom[i][1][1] = b.vel    arr_phantom[i][1][2] = b.potential_U(a)    arr_phantom[i][1][3] = b.kinetic_E()        iteration(a, b)    plt.plot(arr_phantom[:, 0, 0])plt.plot(arr_phantom[:, 1, 0])plt.title('Particles Path: Phantom')plt.xlabel('time (100 microseconds)')plt.ylabel('distance (meters)')plt.legend(['a', 'b'])plt.show()#%% Phantom energyplt.plot(arr_phantom[:, 0, 2] + arr_phantom[:, 0, 3] + arr_phantom[:, 1, 2] + arr_phantom[:, 1, 3])plt.ylim(-10000000000, 10000000000)plt.title('System energy: Phantom')plt.xlabel('time (100 microseconds)')plt.ylabel('energy (joules)')plt.legend(['a', 'b'])plt.show()plt.plot(arr_phantom[:, 0, 2])plt.plot(arr_phantom[:, 0, 3])plt.plot(arr_phantom[:, 1, 2])plt.plot(arr_phantom[:, 1, 3])plt.title('Particle energy: Phantom')plt.xlabel('time (100 microseconds)')plt.ylabel('energy (joules))')plt.legend(['a potential', 'a kinetic', 'b potential', 'b kinetic'])plt.show()#%% Perfectly Ellastica = Particle(mass_base,                  -1 + 2 * np.random.rand(),                 2)b = Particle(mass_base,                  -1 + 2 * np.random.rand(),                 3)time_ellastic = 10000arr_ellastic = np.zeros((time_ellastic, 2, 4))# Index 0: Which time mark# Index 1: Which particle # Index 2: Which particle characteristic (x_pos, vel, potential_U, kinetic_E)collision = time_ellasticfor i in range(time_ellastic):        if a.collided==0 and (collision == time_ellastic):        collision = i    #print('---------',i)    arr_ellastic[i][0][0] = a.x_pos    arr_ellastic[i][0][1] = a.vel    arr_ellastic[i][0][2] = a.potential_U(b)    arr_ellastic[i][0][3] = a.kinetic_E()        arr_ellastic[i][1][0] = b.x_pos    arr_ellastic[i][1][1] = b.vel    arr_ellastic[i][1][2] = b.potential_U(a)    arr_ellastic[i][1][3] = b.kinetic_E()        iteration(a, b, False)    print(a.collided, collision)        plt.plot(arr_ellastic[:, 0, 0])plt.plot(arr_ellastic[:, 1, 0])plt.title('Particles Path: Ellastic Collision')plt.xlabel('time (100 microseconds)')plt.ylabel('distance (meters)')plt.legend(['a', 'b'])plt.show()#%% Ellastic energyplt.plot(arr_ellastic[:, 0, 2] + arr_ellastic[:, 0, 3] + arr_ellastic[:, 1, 2] + arr_ellastic[:, 1, 3])plt.title('System energy: Ellastic Collision')plt.ylim(-10000000000, 10000000000)plt.xlabel('time (100 microseconds)')plt.ylabel('energy (joules)')plt.legend(['a', 'b'])plt.show()plt.plot(arr_ellastic[:, 0, 2])plt.plot(arr_ellastic[:, 0, 3])plt.plot(arr_ellastic[:, 1, 2])plt.plot(arr_ellastic[:, 1, 3])plt.title('Particle energy: Ellastic')plt.xlabel('time (100 microseconds)')plt.ylabel('energy (joules))')plt.legend(['a potential', 'a kinetic', 'b potential', 'b kinetic'])plt.show()#%% Lambda nums = []for i in range(1, 10000000):    nums.append(i/1000000)  lambdas = []for num in nums:    lambdas.append(lambda_F(num))    plt.plot(nums, lambdas)plt.title('Lambda')plt.xlabel('distance')plt.ylabel('lambda')plt.legend([lam])plt.show()#%%def fake_F(r):    return 1/rdef lambda_Force(r, fake_lambda):    return 1/(r  + fake_lambda)fake_forces = []lambda_forces = []for i in range(len(nums)):    fake_forces.append(fake_F(nums[i]))    lambda_forces.append(lambda_Force(nums[i], lambdas[i]))plt.plot(nums, fake_forces)plt.plot(nums, lambda_forces)plt.title('Force with Pseudopotential')plt.xlabel('distance')plt.ylabel('force')plt.legend(['Normal force', 'With psedudo'])plt.ylim(0, 20)plt.show()#%%# collision_if# Index 0 is simulation number# Index 1 is particle # Index 3 is particle's properties # 0 = initial position# 1 = initial velocity # 2 = mass# 3 = final position# 4 = final velocity train = np.zeros((total_train, 2, 6))for i in range(total_train):        a = Particle(mass_base + mass_base * 4 * np.random.rand(),                  -1 + 2 * np.random.rand(),                 np.random.rand() * 5)    b = Particle(mass_base + mass_base * 4 * np.random.rand(),                  -1 + 2 * np.random.rand(),                 np.random.rand() * 5)        train[i][0][0] = a.x_pos    train[i][0][1] = a.vel    train[i][0][2] = a.mass    train[i][1][0] = b.x_pos    train[i][1][1] = b.vel    train[i][1][2] = b.mass         for j in range(10000):        iteration(a, b, False)            train[i][0][3] = a.x_pos    train[i][0][4] = a.vel    train[i][1][3] = b.x_pos    train[i][1][4] = b.vel    train[i][0][5] = a.collideddata_collision_if = {'initial position of a': train[:,0,0],        'initial position of b': train[:,1,0],        'initial velocity of a': train[:,0,1],        'initial velocity of b': train[:,1,1],        'mass of a': train[:,0,2],        'mass of b': train[:,1,2],        'final position of a': train[:,0,3],        'final position of b': train[:,1,3],        'final velocity of a': train[:,0,4],        'final velocity of b': train[:,1,4],        'if collided':train[:,0,5]}df_collision_if = pd.DataFrame(data_collision_if, columns = ['initial position of a',        'initial position of b',        'initial velocity of a',        'initial velocity of b',        'mass of a',        'mass of b',        'final position of a',        'final position of b',        'final velocity of a',        'final velocity of b',        'if collided'])df_collision_if.to_csv('/Users/edwintomy/One Dimensional Gravity Simulator/if_collision/L1_TS4_train.csv')test = np.zeros((total_test, 2, 6))for i in range(total_test):        a = Particle(mass_base + mass_base * 4 * np.random.rand(),                  -1 + 2 * np.random.rand(),                 np.random.rand() * 5)    b = Particle(mass_base + mass_base * 4 * np.random.rand(),                  -1 + 2 * np.random.rand(),                 np.random.rand() * 5)        test[i][0][0] = a.x_pos    test[i][0][1] = a.vel    test[i][0][2] = a.mass    test[i][1][0] = b.x_pos    test[i][1][1] = b.vel    test[i][1][2] = b.mass         for j in range(10000):        iteration(a, b, False)            test[i][0][3] = a.x_pos    test[i][0][4] = a.vel    test[i][1][3] = b.x_pos    test[i][1][4] = b.vel    test[i][0][5] = a.collided        #print(a.x_pos, a.vel, b.x_pos, b.vel)data_test = {'initial position of a': test[:,0,0],        'initial position of b': test[:,1,0],        'initial velocity of a': test[:,0,1],        'initial velocity of b': test[:,1,1],        'mass of a': test[:,0,2],        'mass of b': test[:,1,2],        'final position of a': test[:,0,3],        'final position of b': test[:,1,3],        'final velocity of a': test[:,0,4],        'final velocity of b': test[:,1,4],        'if collided': test[:,0,5]}df_test = pd.DataFrame(data_test, columns = ['initial position of a',        'initial position of b',        'initial velocity of a',        'initial velocity of b',        'mass of a',        'mass of b',        'final position of a',        'final position of b',        'final velocity of a',        'final velocity of b',        'if collided'])df_test.to_csv('/Users/edwintomy/One Dimensional Gravity Simulator/if_collision/L1_TS4_test.csv')#%%# collision_if with velocity as only parameter# Index 0 is simulation number# Index 1 is particle # Index 3 is particle's properties # 0 = initial position# 1 = initial velocity # 2 = mass# 3 = final position# 4 = final velocity only_vel_train = np.zeros((total_train, 2, 6))for i in range(total_train):        a = Particle(mass_base,                  -1 + 2 * np.random.rand(),                 3)    b = Particle(mass_base,                  -1 + 2 * np.random.rand(),                 2)        only_vel_train[i][0][0] = a.x_pos    only_vel_train[i][0][1] = a.vel    only_vel_train[i][0][2] = a.mass    only_vel_train[i][1][0] = b.x_pos    only_vel_train[i][1][1] = b.vel    only_vel_train[i][1][2] = b.mass         for j in range(10000):        iteration(a, b, False)            only_vel_train[i][0][3] = a.x_pos    only_vel_train[i][0][4] = a.vel    only_vel_train[i][1][3] = b.x_pos    only_vel_train[i][1][4] = b.vel    only_vel_train[i][0][5] = a.collideddata_collision_if = {'initial position of a': only_vel_train[:,0,0],        'initial position of b': only_vel_train[:,1,0],        'initial velocity of a': only_vel_train[:,0,1],        'initial velocity of b': only_vel_train[:,1,1],        'mass of a': only_vel_train[:,0,2],        'mass of b': only_vel_train[:,1,2],        'final position of a': only_vel_train[:,0,3],        'final position of b': only_vel_train[:,1,3],        'final velocity of a': only_vel_train[:,0,4],        'final velocity of b': only_vel_train[:,1,4],        'if collided':only_vel_train[:,0,5]}df_collision_if = pd.DataFrame(data_collision_if, columns = ['initial position of a',        'initial position of b',        'initial velocity of a',        'initial velocity of b',        'mass of a',        'mass of b',        'final position of a',        'final position of b',        'final velocity of a',        'final velocity of b',        'if collided'])df_collision_if.to_csv('/Users/edwintomy/One Dimensional Gravity Simulator/if_collision/L1_TS4_train_vel.csv')only_vel_test = np.zeros((total_test, 2, 6))for i in range(total_test):        a = Particle(mass_base,                  -1 + 2 * np.random.rand(),                 3)    b = Particle(mass_base,                  -1 + 2 * np.random.rand(),                 2)        only_vel_test[i][0][0] = a.x_pos    only_vel_test[i][0][1] = a.vel    only_vel_test[i][0][2] = a.mass    only_vel_test[i][1][0] = b.x_pos    only_vel_test[i][1][1] = b.vel    only_vel_test[i][1][2] = b.mass         for j in range(10000):        iteration(a, b, False)            only_vel_test[i][0][3] = a.x_pos    only_vel_test[i][0][4] = a.vel    only_vel_test[i][1][3] = b.x_pos    only_vel_test[i][1][4] = b.vel    only_vel_test[i][0][5] = a.collided        #print(a.x_pos, a.vel, b.x_pos, b.vel)data_only_vel_test = {'initial position of a': only_vel_test[:,0,0],        'initial position of b': only_vel_test[:,1,0],        'initial velocity of a': only_vel_test[:,0,1],        'initial velocity of b': only_vel_test[:,1,1],        'mass of a': only_vel_test[:,0,2],        'mass of b': only_vel_test[:,1,2],        'final position of a': only_vel_test[:,0,3],        'final position of b': only_vel_test[:,1,3],        'final velocity of a': only_vel_test[:,0,4],        'final velocity of b': only_vel_test[:,1,4],        'if collided': only_vel_test[:,0,5]}df_only_vel_test = pd.DataFrame(data_only_vel_test, columns = ['initial position of a',        'initial position of b',        'initial velocity of a',        'initial velocity of b',        'mass of a',        'mass of b',        'final position of a',        'final position of b',        'final velocity of a',        'final velocity of b',        'if collided'])df_only_vel_test.to_csv('/Users/edwintomy/One Dimensional Gravity Simulator/if_collision/L1_TS4_test_vel.csv')#%%df_train = pd.read_csv('if_collision/L1_TS4_train_vel.csv')df_test = pd.read_csv('if_collision/L1_TS4_test_vel.csv')x = df_train[[        'initial velocity of a',        'initial velocity of b']]y = df_train['if collided']x_test = df_test[[        'initial velocity of a',        'initial velocity of b']]y_test = df_test['if collided']y.loc[y > 0] = 1y_test.loc[y_test > 0] = 1logistic_regression = LogisticRegression()logistic_regression.fit(x, y)y_pred = logistic_regression.predict(x_test)score = logistic_regression.score(x_test, y_test)print(score)cnf_matrix = metrics.confusion_matrix(y_test, y_pred)class_names=[0,1] # name  of classesfig, ax = plt.subplots()tick_marks = np.arange(len(class_names))plt.xticks(tick_marks, class_names)plt.yticks(tick_marks, class_names)# create heatmapsns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')ax.xaxis.set_label_position("top")plt.tight_layout()plt.title('Confusion matrix', y=1.1)plt.ylabel('Actual label')plt.xlabel('Predicted label')#%%df_train = pd.read_csv('if_collision/L1_TS4_train.csv')df_test = pd.read_csv('if_collision/L1_TS4_test.csv')x = df_train[[        'initial velocity of a',        'initial velocity of b']]y = df_train['if collided']x_test = df_test[[        'initial velocity of a',        'initial velocity of b']]y_test = df_test['if collided']y.loc[y > 0] = 1y_test.loc[y_test > 0] = 1logistic_regression = LogisticRegression()logistic_regression.fit(x, y)y_pred = logistic_regression.predict(x_test)score = logistic_regression.score(x_test, y_test)print(score)cnf_matrix = metrics.confusion_matrix(y_test, y_pred)class_names=[0,1] # name  of classesfig, ax = plt.subplots()tick_marks = np.arange(len(class_names))plt.xticks(tick_marks, class_names)plt.yticks(tick_marks, class_names)# create heatmapsns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')ax.xaxis.set_label_position("top")plt.tight_layout()plt.title('Confusion matrix', y=1.1)plt.ylabel('Actual label')plt.xlabel('Predicted label')#%%    corr = df_train.corr()sns.heatmap(corr,             xticklabels=corr.columns.values,            yticklabels=corr.columns.values)sns.plt.show()#%%